<#
.SYNOPSIS
.DESCRIPTION
Automates Windows and IIS feature enablement based on config.json.
Supports: Install, Validate, Rollback operations with separate logs and state tracking.
.NOTES
Created on: 4 Sept 2025
#>
param(
    [Parameter(Mandatory = $true)]
    [ValidateSet("install","validate","rollback")]
    [string]$Action
)

$ConfigPath = ".config.json"

# --- Function to write logs per operation using appropriate log file ---
function Write-Log {
    param([string]$Message, [string]$Level = "INFO")

    $logFilePath = switch ($Action) {
        "install" { $config.LogFiles.Install }
        "validate" { $config.LogFiles.Validate }
        "rollback" { $config.LogFiles.Rollback }
        default { "C:\\WindowsSetupScript.log" }
    }
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    Write-Output $logEntry
    Add-Content -Path $logFilePath -Value $logEntry
}

# --- Load Config ---
if (-Not (Test-Path $ConfigPath)) {
    Write-Host "Configuration file not found: $ConfigPath"
    exit 1
}
$config = Get-Content -Path $ConfigPath -Raw | ConvertFrom-Json

Write-Log "$Action operation started."

# --- OS & Admin Check (Only for install/rollback) ---
if ($Action -ne "validate") {
    $currentOS = (Get-CimInstance Win32_OperatingSystem).Caption
    Write-Log "Detected OS: $currentOS"
    if ($config.SupportedOS -contains $currentOS) {
        Write-Log "OS is supported: $currentOS"
    }
    else {
        Write-Log "OS not listed in supported config." "WARNING"
        $continue = $null
        while ($null -eq $continue) {
            $continue = Read-Host "Current OS is not in SupportedOS list. Continue anyway? (Y/N)"
            if ($continue.ToUpper() -eq 'Y') {
                Write-Log "User chose to continue the script."
                continue
            }
            elseif ($continue.ToUpper() -eq 'N') {
                Write-Log "Terminated due to unsupported OS"
                exit 1
            }
            else { $continue = $null }
        }
    }
    Write-Log "OS verified."

    $isAdmin = ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
    if (-not $isAdmin) {
        Write-Log "Script is not running as administrator!" "WARNING"
        $proceed = $null
        while ($null -eq $proceed) {
            $proceed = Read-Host "You are NOT running as Administrator. Do you still want to continue? (Y/N)"
            if ($proceed.ToUpper() -eq 'Y') {
                Write-Log "User chose to continue the script."
                continue
            }
            elseif ($proceed.ToUpper() -eq 'N') {
                Write-Log "Terminated due to admin access"
                exit 1
            }
            else { $proceed = $null }
        }
    }
    Write-Log "Admin check complete."
}

# Path to state file for tracking installed features during install
$StateFilePath = $config.StateFile

switch ($Action) {
    "install" {
        $InstalledFeatures = @()

        Write-Log "Starting installation of Windows features..."

        foreach ($feature in $config.WindowsFeatures.FeaturesToEnable) {
            try {
                $alreadyInstalled = Get-WindowsFeature -Name $feature | Where-Object { $_.Installed }
                if (-not $alreadyInstalled) {
                    Install-WindowsFeature -Name $feature -IncludeManagementTools -ErrorAction Stop | Out-Null
                    Write-Log "Installed feature: $feature"
                    $InstalledFeatures += $feature
                }
                else {
                    Write-Log "Feature already installed: $feature"
                }
            }
            catch {
                Write-Log "Failed to install feature $feature : $_" "ERROR"
            }
        }

        # Save installed features to state file for rollback
        if ($InstalledFeatures.Count -gt 0) {
            $InstalledFeatures | ConvertTo-Json | Set-Content -Path $StateFilePath -Force
            Write-Log "Saved installed features list to state file."
        }
        else {
            Write-Log "No new features installed, state file not updated."
        }

        Write-Log "Triggering system reboot to finalize installation."
        Write-Log "MARKER: RESTART_REQUIRED_AFTER_STEP_1"
        Write-Log "Install operation Completed."
        Start-Sleep -Seconds 5
        Restart-Computer -Force
    }

    "validate" {
        $success = $true
        Write-Log "Starting validation of installed Windows features..."

        foreach ($feature in $config.WindowsFeatures.FeaturesToEnable) {
            $alreadyInstalled = Get-WindowsFeature -Name $feature | Where-Object { $_.Installed }
            if (-not $alreadyInstalled) {
                Write-Log "Feature NOT enabled as expected: $feature" "WARNING"
                $success = $false
            }
            else {
                Write-Log "Feature enabled as expected: $feature"
            }
        }

        if ($success) {
            Write-Log "Validation successful. All features in expected state."
        }
        else {
            Write-Log "Validation completed with warnings/errors." "WARNING"
        }
    }

    "rollback" {
        Write-Log "Starting rollback operation..."

        if (-Not (Test-Path $StateFilePath)) {
            Write-Log "State file not found. Unable to determine which features to rollback." "ERROR"
            exit 1
        }

        $featuresToRemove = Get-Content -Path $StateFilePath | ConvertFrom-Json

        foreach ($feature in $featuresToRemove) {
            try {
                $installed = Get-WindowsFeature -Name $feature | Where-Object { $_.Installed }
                if ($installed) {
                    Uninstall-WindowsFeature -Name $feature -ErrorAction Stop | Out-Null
                    Write-Log "Rolled back (disabled) feature: $feature"
                }
                else {
                    Write-Log "Feature already not installed (no rollback needed): $feature"
                }
            }
            catch {
                Write-Log "Rollback failed (disable) for feature $feature : $_" "ERROR"
            }
        }

        # Optionally, remove the state file after rollback
        Remove-Item -Path $StateFilePath -Force -ErrorAction SilentlyContinue
        Write-Log "Removed state file after rollback."

        Write-Log "Triggering system reboot to finalize rollback."
        Write-Log "MARKER: RESTART_REQUIRED_ROLLBACK_STEP_1"
        Write-Log "Rollback operation Completed."
        Start-Sleep -Seconds 5
        Restart-Computer -Force
    }
}